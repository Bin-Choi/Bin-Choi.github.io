---
title: "[포스팅 예시] 이곳에 제목을 입력하세요"
excerpt: "본문의 주요 내용을 여기에 입력하세요"

categories:
  - Categories3
tags:
  - [tag1, tag2]

permalink: /categories3/post-name-here-3/

toc: true
toc_sticky: true

date: 2022-07-24
last_modified_at: 2022-07-24
---

### 리눅스 프로세스 관리 개요

리눅스에서 프로세스(Process)는 실행 중인 프로그램 또는 명령어를 말하며, 시스템의 중요한 자원(메모리, CPU 등)을 효율적으로 관리합니다. 리눅스 프로세스 관리에 대해 알아보겠습니다.

---

### **프로세스의 기본 개념**

### 1. **프로세스 ID (PID)**

- 모든 프로세스는 고유한 프로세스 ID(PID)를 가집니다.
- PID는 프로세스를 식별하고 관리하는 데 사용됩니다.

### 2. **부모-자식 관계**

- 모든 프로세스는 **부모 프로세스**로부터 생성됩니다.
- 최상위 부모 프로세스는 init(systemd)이며, PID가 `1`입니다.

### 3. **프로세스 상태**

- **R (Running)**: 실행 중이거나 실행 준비 상태.
- **S (Sleeping)**: 대기 상태.
- **D (Uninterruptible)**: 종료 불가능한 대기 상태(I/O 작업 중).
- **Z (Zombie)**: 종료되었지만 부모 프로세스가 처리하지 않은 상태.
- **T (Stopped)**: 중지된 상태(예: `Ctrl+Z`로 중단).

---

### **프로세스 관련 주요 명령어**

### 1. **프로세스 목록 확인**

- **`ps` 명령어**: 현재 실행 중인 프로세스를 확인.
    
    ```bash
    ps aux
    
    ```
    
    - `a`: 다른 사용자의 프로세스도 표시.
    - `u`: 프로세스 소유자, CPU 사용량 등 상세 정보.
    - `x`: 로그인 세션에 연결되지 않은 프로세스도 표시.
- **출력 예시**:
    
    ```
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         1  0.0  0.2 168748  11248 ?        Ss   10:00   0:02 /sbin/init
    hong      1234  0.1  0.5  81120  24532 pts/1    S+   10:05   0:00 python script.py
    
    ```
    

### 2. **실시간 프로세스 모니터링**

- **`top` 명령어**:
    - CPU, 메모리 사용량이 높은 프로세스를 실시간으로 확인.
    
    ```bash
    top
    ```
    
- **`htop` 명령어**(추가 설치 필요):
    - `top`의 개선 버전으로 인터페이스가 더 직관적.
    
    ```bash
    sudo apt install htop
    hto
    ```
    

### 3. **프로세스 종료**

- **`kill` 명령어**: 프로세스를 종료.
    
    ```bash
    kill -9 PID
    ```
    
    - `9`: 강제 종료(SIGNAL 9).
- **`killall` 명령어**: 프로세스 이름으로 종료.
    
    ```bash
    killall 프로세스이름
    ```
    
    - **예시**: 모든 `python` 프로세스 종료:
        
        ```bash
        killall python
        ```
        

### 4. **백그라운드 작업**

- 명령어를 백그라운드에서 실행:
    
    ```bash
    명령어 &
    ```
    
    - **예시**: `sleep` 명령어를 백그라운드 실행:
        
        ```bash
        sleep 60 &
        ```
        
- 백그라운드 작업 목록 확인:
    
    ```bash
    jobs
    ```
    
- 백그라운드 작업을 포그라운드로 가져오기:
    
    ```bash
    fg %작업번호
    ```
    
- 작업을 다시 백그라운드로 보내기:
    
    ```bash
    bg %작업번호
    ```
    

---

### **프로세스 우선순위와 `nice`/`renice`**

### 1. **프로세스 우선순위**

- 리눅스에서는 프로세스 우선순위(priority)를 통해 CPU 사용권을 조절.
- 우선순위는 `20`(가장 높은 우선순위)부터 `19`(가장 낮은 우선순위)까지 설정.

### 2. **`nice` 명령어**

- 새로운 프로세스를 지정된 우선순위로 실행:
    
    ```bash
    nice -n 우선순위 명령어
    ```
    
    - **예시**: 낮은 우선순위(`10`)로 `gzip` 실행:
        
        ```bash
        nice -n 10 gzip largefil
        ```
        

### 3. **`renice` 명령어**

- 실행 중인 프로세스의 우선순위를 변경:
    
    ```bash
    renice 우선순위 -p PID
    
    ```
    
    - **예시**: PID가 `1234`인 프로세스를 우선순위 `5`로 변경:
        
        ```bash
        renice 5 -p 1234
        ```
        

---

### **좀비 프로세스(Zombie Process)**

### 1. **정의**

- 부모 프로세스가 자식 프로세스의 종료 상태를 수거하지 않아 남아 있는 프로세스.
- 시스템 자원은 사용하지 않지만, 너무 많으면 PID를 소진시켜 시스템 성능에 영향을 줄 수 있음.

### 2. **좀비 프로세스 확인**

- `ps` 명령에서 상태(`STAT`)가 `Z`인 프로세스:
    
    ```bash
    ps aux | grep Z
    ```
    

### 3. **해결 방법**

1. 부모 프로세스를 종료:
    
    ```bash
    kill -9 부모_PID
    ```
    
2. 부모 프로세스 종료가 불가능하면 시스템 재부팅.

---

### **프로세스 제어 신호**

### 1. **`kill` 명령의 신호**

- 리눅스에서 프로세스는 다양한 신호(Signal)를 통해 제어 가능.
- 주요 신호:
    
    
    | **신호 번호** | **이름** | **설명** |
    | --- | --- | --- |
    | `1` | `SIGHUP` | 프로세스 재시작. |
    | `9` | `SIGKILL` | 강제 종료. |
    | `15` | `SIGTERM` | 정상 종료 요청(기본). |
    | `19` | `SIGSTOP` | 프로세스 일시 중지. |

### 2. **신호 보내기**

- `kill` 명령어로 신호 전달:
    
    ```bash
    kill -SIGNAL PID
    ```
    
    - **예시**: PID가 `1234`인 프로세스 강제 종료:
        
        ```bash
        kill -9 1234
        ```
        

---

### **데몬 프로세스(Daemon Process)**

### 1. **정의**

- 시스템에서 **백그라운드**로 실행되며, 주로 서비스 제공에 사용.
- 예: `httpd`(Apache), `sshd`(SSH 데몬).

### 2. **데몬 관리**

- 데몬 상태 확인 및 제어:
    
    ```bash
    systemctl status 서비스이름
    systemctl start 서비스이름
    systemctl stop 서비스이름
    ```
    

---

### **프로세스 관련 실전 예제**

1. **특정 사용자의 모든 프로세스 종료**
    
    ```bash
    pkill -u 사용자이름
    ```
    
    - **예시**: 사용자 `hong`의 모든 프로세스 종료:
        
        ```bash
        pkill -u hong
        ```
        
2. **CPU 사용률이 높은 프로세스 확인**
    
    ```bash
    ps aux --sort=-%cpu | head
    ```
    
3. **메모리 사용률이 높은 프로세스 확인**
    
    ```bash
    ps aux --sort=-%mem | head
    
    ```
    

---

## **리눅스 `ps` 명령어**

`ps`(Process Status)는 현재 실행 중인 **프로세스의 상태를 확인**하는 데 사용하는 명령어입니다. 시스템에서 실행 중인 프로세스의 PID, 사용자, CPU 및 메모리 사용량, 실행 명령 등을 보여줍니다. 이를 통해 시스템 상태를 모니터링하고 프로세스 관리 작업에 활용할 수 있습니다.

---

### **기본 사용법**

1. **현재 셸에서 실행 중인 프로세스 보기**:
    
    ```bash
    ps
    ```
    
    - 출력 예시:
        
        ```
          PID TTY          TIME CMD
         1234 pts/0    00:00:00 bash
         2345 pts/0    00:00:00 ps
        ```
        
    - **PID**: 프로세스 ID.
    - **TTY**: 터미널 세션.
    - **TIME**: CPU 사용 시간.
    - **CMD**: 실행 중인 명령어.
2. **모든 사용자 프로세스 확인**:
    
    ```bash
    ps -e
    ```
    
    또는
    
    ```bash
    ps -A
    ```
    
3. **현재 사용자 프로세스 보기**:
    
    ```bash
    ps -u 사용자이름
    ```
    
    - **예시**:
        
        ```bash
        ps -u hong
        ```
        

---

### **`ps` 명령의 주요 옵션**

| **옵션** | **설명** |
| --- | --- |
| `-e` 또는 `-A` | 시스템의 모든 프로세스 표시. |
| `-f` | 풀 포맷 출력(프로세스의 부모/자식 관계 표시). |
| `-u 사용자` | 특정 사용자의 프로세스만 표시. |
| `-p PID` | 특정 PID에 해당하는 프로세스만 표시. |
| `--forest` | 프로세스 계층 구조를 시각적으로 표시. |
| `--sort=KEY` | 지정된 키(KEY)를 기준으로 정렬(예: `%cpu`, `%mem`). |

---

### **고급 사용법**

### 1. **상세 정보 보기**

- **명령어**:
    
    ```bash
    ps -ef
    ```
    
    - **출력 필드**:
        
        ```
        UID        PID  PPID  C STIME TTY          TIME CM
        ```
        
        - **UID**: 프로세스를 실행한 사용자.
        - **PID**: 프로세스 ID.
        - **PPID**: 부모 프로세스 ID.
        - **C**: CPU 사용률.
        - **STIME**: 프로세스 시작 시간.
        - **TTY**: 프로세스가 실행된 터미널.
        - **CMD**: 실행된 명령어.

---

### 2. **특정 프로세스 검색**

- **PID로 검색**:
    
    ```bash
    ps -p PID
    ```
    
    - **예시**:
        
        ```bash
        ps -p 1234
        ```
        
- **프로세스 이름으로 검색**:
    
    ```bash
    ps -C 명령어이름
    ```
    
    - **예시**:
        
        ```bash
        ps -C sshd
        ```
        

---

### 3. **현재 사용자 프로세스 확인**

- **명령어**:
    
    ```bash
    ps -u
    
    ```
    
    - 현재 로그인된 사용자의 모든 프로세스를 표시.

---

### 4. **CPU 또는 메모리 사용량 기준 정렬**

- **명령어**:
    
    ```bash
    ps -eo pid,comm,%cpu,%mem --sort=-%cpu
    ```
    
    - **출력 필드**:
        - **pid**: 프로세스 ID.
        - **comm**: 실행된 명령어.
        - **%cpu**: CPU 사용량.
        - **%mem**: 메모리 사용량.
- **메모리 사용량 기준 정렬**:
    
    ```bash
    ps -eo pid,comm,%mem --sort=-%mem
    ```
    

---

### 5. **프로세스 계층 구조 확인**

- **명령어**:
    
    ```bash
    ps -ef --forest
    ```
    
    - 프로세스 간의 부모/자식 관계를 트리 형태로 시각화.

---

### 6. **자주 사용하는 조합 명령**

- **모든 프로세스를 풀 포맷으로 출력**:
    
    ```bash
    ps aux
    ```
    
    - **a**: 모든 사용자의 프로세스.
    - **u**: 상세 정보 출력.
    - **x**: 터미널에 연결되지 않은 프로세스 포함.
- **특정 사용자와 이름 기준으로 필터링**:
    
    ```bash
    ps -u username -C 명령어이름
    ```
    
    - **예시**:
        
        ```bash
        ps -u hong -C python
        ```
        

---

### **출력 필드 설명**

| **필드** | **설명** |
| --- | --- |
| `PID` | 프로세스 ID. |
| `PPID` | 부모 프로세스 ID. |
| `UID` | 프로세스를 실행한 사용자. |
| `%CPU` | 프로세스가 사용 중인 CPU 비율. |
| `%MEM` | 프로세스가 사용 중인 메모리 비율. |
| `TTY` | 프로세스가 연결된 터미널. |
| `STAT` | 프로세스 상태(예: R, S, D, Z). |
| `START` | 프로세스가 시작된 시간. |
| `CMD` | 실행된 명령어와 관련된 전체 경로 또는 명령. |

---

### **실전 예제**

### 1. **CPU 사용률이 높은 프로세스 확인**

```bash
ps -eo pid,comm,%cpu --sort=-%cpu | head
```

### 2. **특정 사용자의 프로세스 종료**

1. 특정 사용자 `hong`의 모든 프로세스 확인:
    
    ```bash
    ps -u hong
    
    ```
    
2. 특정 PID를 종료:
    
    ```bash
    kill -9 PID
    
    ```
    

### 3. **좀비 프로세스 확인**

```bash
ps aux | grep Z

```

### 4. **특정 시간 이후 실행된 프로세스 확인**

```bash
ps -eo pid,comm,start | grep "Jan"

```

---

### **`ps` vs `top`**

| **구분** | **`ps`** | **`top`** |
| --- | --- | --- |
| **용도** | 프로세스의 정적 상태 확인. | 실시간으로 프로세스 모니터링. |
| **정보 갱신** | 명령 실행 시점의 스냅샷 정보 제공. | 자동으로 프로세스 상태 갱신. |
| **정렬 및 필터링** | 다양한 옵션으로 세부적인 정보 제공. | 인터페이스에서 직접 키 입력으로 조작 가능. |
