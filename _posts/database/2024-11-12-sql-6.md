---
title: "SQL 추가 정리"
excerpt: "SQLD 기출 문제를 풀고 부족한 개념 보충"

categories:
  - Database
tags:
  - [tag1, tag2]

permalink: /database/sql/6

toc: true
toc_sticky: true

date: 2024-11-12
last_modified_at: 2024-11-12
---

## 데이터 모델링의 이해
---
### 속성
업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위

### 엔티티의 분류

1. 유무형에 따른 분류

  - **유형엔티티** : 물리적인 형태가 있고, 안정적이며 지속적으로 활용되는 엔티티
  - **개념엔티티** : 물리적인 형태는 존재하지 않고 개념적 정보로 구분되는 엔티티
  - **사건엔티티** : 업무를 수행함에 따라 발생되는 엔티티로 비교적 발생량이 많으며 각종 통계에 이용될 수 있음

2. 발생시점에 따른 분류

  - **기본엔티티** : 업무에 원래 존재하는 정보. 엔티티와의 관계에 의해 생성되지 않고 독립적으로 생성 가능, 다른 엔티티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 갖는다.
  - **중심엔티티** : 기본엔티티로부터 발생. 업무에서 중심적인 역할. 다른 엔티티와의 관계를 통해 행위엔티티를 생성
  - **행위엔티티** : 두 개 이상의 부모 엔티티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가.

### 속성의 분류

- **기본속성** : 업무분석을 통해 바로 정의한 속성
  - ex) 상품명, 가격, 주문수량
- **설계속성** : 원래 업무상 존재하지는 않지만 설계를 하면서 도출해내는 속성
  - ex) 주문번호, 예약번호, 고객번호, 상품코드
- **파생속성** : 다른 속성으로부터 계산이나 변형이 되어 생기는 속성
  - ex) 나이(생년월일에 의해 계산), 근무기간(입사일에 의해 계산)

### 모델링의 단계 중 가장 재사용성이 높은 모델링
- 논리적 데이터 모델링 : 논리적 데이터 모델링은 키, 속성, 관계 등을 포현하여 재사용성이 높다.

### 스키마 구조
- 개념 스키마 : 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현

### 데이터 모델링시 주의점
**중복** 최소화, **비유연성** 최소화, **비일관성** 최소화
- **중복** : 여러 장소의 데이터베이스에 같은 정보를 저장하지 않도록 하여 중복성을 최소화
- **비유연성** : 데이터의 정의를 데이터의 사용 프로세스와 분리하여 유연성을 높임(여러 데이터 모델에서 쓰기 편하게)
- **비일관성** : 데이터간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터가 유지

### 관계 표기법
- 관계명
- 관계차수
- 관계선택사양

### 슈퍼 / 서브타입 데이터 모델의 변환타입

DB 모델링기법 중 슈퍼/서브타입 모델(엔티티가 상속관계)가 있는데,
논리 모델은 같지만 실제 물리모델은 RollUp(Single-Type), RollDown(Plus-Type), Identity(One-To-One Type) 중 하나로 구현한다.

- Single Type : 전체를 하나의 테이블로 통합
- Plus Type : 각각의 서브타입에 슈퍼타입을 합하여 슈퍼타입+서브타입 테이블로 구성
- One to One Type : 슈퍼타입, 서브타입 테이블들을 각각 개별 테이블로 구성

**[모델 비교]**

|              구분              	|          OneToOne Type         	|                  Plus Type                  	|           Single Type           	|
|:------------------------------:	|:------------------------------:	|:-------------------------------------------:	|:-------------------------------:	|
|              특징              	|        개별 테이블 유지        	|            슈퍼 + 서브타입 테이블           	|          하나의 테이블          	|
|             확장성             	|             우수함             	|                     보통                    	|               나쁨              	|
|            조인 성능           	|              나쁨              	|                     나쁨                    	|              우수함             	|
|           I/O량 성능           	|              좋음              	|                     좋음                    	|               나쁨              	|
|           관리용이성           	|            좋지않음            	|                   좋지않음                  	|            좋음(1개)            	|
| 트랜잭션 유형에 따른 선택 방법 	| 개별 테이블로 접근이 많은 경우 	| 슈퍼 + 서브 형식으로 데이터를 처리하는 경우 	| 전체를 일괄적으로 처리하는 경우 	|

## SQL 기본 및 활용
---

### NULL
- Null 값은 아직 알려지지 않은 미지의 값.

Null 의 비교는 IS NULL / NOT NULL 만 할수있음 

COL의 값으로 (2, NULL) 를 가지고 있을 때,
```sql
WHERE A.COL NOT IN (SELECT COL FROM TBL);
```
다음의 쿼리를 실행시 아무것도 조건에 선택되지 않음 (NOT IN에서 Null 과 비교시 무조건 FALSE를 반환)

### 트랜잭션
트랜잭션은 명시적으로 `COMMIT` 이나 `ROLLBACK`을 호출하지 않으면 이전 트랜잭션이 열린 상태로 **유지**된다!!<br/>
꼭 마무리해주자!!<br/>
마무리 안한 상태에서 새로 트랜잭션을 실행하면 에러가 나거나 예상치 않은 결과가 발생할 수 있음 <br/>
- `BEGIN TRANSACTION`을 여러 번 사용해도, 내부적으로 하나의 트랜잭션으로 간주
- 이 경우, 한번이라도 `ROLLBACK`이 호출되면, 모든 트랜잭션이 취소
- 중첩 트랜잭션을 구현하려면 `SAVEPOINT`, `ROLLBACK TO SAVEPOINT`를 사용

### ANSI JOIN 과 Oracle Join

**ANSI JOIN**
- 대표적으로 Inner Join, Outer Join, Cross Join, Self Join 있다.
- Join시 Join을 명시
```sql
SELECT *
        FROM TABLE_A T1

        LEFT OUTER JOIN
        TABLE_B T2
        ON T1.COULMN = T2.COLUMN;
```
**Natural Join** <br/>
:Equi Join. 양쪽 테이블의 동일한 이름의 모든 컬럼을 기준으로 조인이 된다.<br/>
같은 컬럼이 1개일 때 사용하는 것이 좋다.<br/>
동일 컬럼의 타입이 다를 경우 오류발생.<br/>
Alias를 쓰지 않는다.<Br/>

**Oracle Join**
Oracle Join이 조금 더 간결하다.
- ANSI Join이 Join의 종류를 명시하며 테이블을 하나하나씩 붙여 나가는 구조
- Oracle Join은 **가져오고자 하는 컬럼이 포함된 모든 테이블들을 일단 FROM 절에 기술**
- WHERE 절에 Join 조건을 명시한다.

```sql
SELECT *
       FROM TABLE_1 T1, TABLE_2 T2
       WHERE T1.COLUMN = T2.COLUMN;
```
- ANSI Join 과 비교하면 어떤 테이블이 중심이 되는지 명확히 알 수가 없다.
- 따라서, Outer Join 시에는 조인 당하는 테이블에 반드시 `(+)` 표기를 해준다.
- Full Outer Join 은 불가능하다.

```sql
-- TABLE_1이 메인 테이블일 경우
SELECT *
       FROM TABLE_1 T1, TABLE_2 T2
       WHERE T1.COLUMN = T2.COLUMN(+);
```

### PL/SQL (Procedural Language extension to SQL)
- SQL을 확장한 절차적 언어
- 유저 프로세스가 PL/SQL 블록을 보내면, 서버 프로세서는 PL/SQL Engine 에서 해당 블록을 받고 SQL과 Procedural를 나눠서 SQL은 SQL statement Executer로 보낸다.
- PL/SQL 프로그램의 종류는 크게 Proceduer, Function, Trigger 로 나뉘어 진다.
- 오라클엣어 지원하는 프로그래밍 언어의 특성을 수용하여 SQL에서는 사용할 수 없는 절차적 프로그래밍 기능을 가지고 있다.

장점
 - 프로시저 생성자와 SQL의 통합
- 성능 향상 : 잘 만들어진 PL/SQL 명령문이라는 가정하에 좋아진다.
- 모듈식 프로그램 개발 가능 : 논리적인 작업 을 진행하는 여러 명령어들을 하나의 블록을 만들 수 있다.
- 이식성이 좋다
- 예외 처리 가능

기본 구조
- DECLARE : 선언부 (옵션)
- BEGINE : 실행부 (필수)
- EXCEPTION : 예외 처리부 (옵션) 
- END : 실행 종료 (필수)

### NL 조인
NL 조인은 두 테이블이 조인을 할 때, 드라이빙 테이블(Outer 테이블)에서 결합 조건에 일치하는 레코드를 내부 테이블(Inner Table)에서 조인하는 방식이다.
- Outer Join에서 만족하는 레코드가 적을수록 NL 조인에서 효율이 좋다.
- 조인 조건에 해당하는 컬럼들은 인덱스를 가지고 있어야한다.
- 순차적이며, 프로그래밍에서 FOR, WHILE문과 같은 구조로 수행
- 선행테이블은 풀스캔하므로, 크기가 작을수록 유리
- 랜덤 액세스 방식으로 데이터를 읽으므로 처리 범위가 좁은 것이 유리
- 온라인 트랜잭션 환경에 적합한 조인

### 해시 조인
HASH 조인은 조인될 **두 테이블 중 하나를 해시 테이블로 선정**하여 조인될 테이블의 조인 키 값을 **해시 알고리즘**으로 비교하여 매치되는 결과값을 얻는 방식<Br/>
HASH JOIN은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며 `=` 비교를 통한 조인에서만 사용될 수 있다.<br/>
주로 많은 양의 데이터를 조인해야 하는 경우에 사용

- JOIN 컬럼에 적당한 **인덱스가 없어** NL JOIN이 비효율적일 때
- JOIN Access 양이 많아 Random Access 부하가 심할 때
- Sort Merge Join을 하기에는 두 테이블이 너무 커 **Sort 부하가 심할 때**
- 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 **대용량 테이블을 JOIN 할 떄** 

**성능 개선 포인트**
- 해시 맵으로 만들 **Build Input 테이블이 Hash Area에 담길 정도로 충분히 작아야 함**
- Build Input 해시 키 칼럼에 중복 값이 거의 없어야 효율적인 동작
- 충분한 PGA 메모리 확보

### 비교연산자
- =, <, >, IS NULL 에는 단일행!!!!!!!
- 다중행 비교시에는
  - IN
  - EXISTS
  - ALL
  - ANY

특히 EXISTS는 서브쿼리를 대상으로만 사용. 주의할 것
```sql
WHERE 컬럼 EXISTS (~~~~~~);
-> 불가능!!
```
### 테이블 생성 후 복제
(CREATE TABLE AS SELECT ~~) 시 NOU NULL 제약조건만 복제된다.

### TO_DATE
문자열을 TO_DATE 함수로 DATE 형으로 밖꿀 때, 연도는 올해, 월은 이번 달, 일은 1일을 기본값으로 하여 생성한다.

